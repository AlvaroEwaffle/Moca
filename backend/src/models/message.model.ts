import mongoose, { Document, Schema } from 'mongoose';

// Message metadata sub-schema
const MessageMetadataSchema = new Schema({
  timestamp: { type: Date, default: Date.now },
  processed: { type: Boolean, default: false }, // Whether message has been processed by AI
  isConsolidated: { type: Boolean, default: false }, // Multiple messages merged
  originalMids: [{ type: String }], // Original message IDs if consolidated
  aiGenerated: { type: Boolean, default: false }, // Generated by AI or rules
  processingTime: { type: Number, default: 0 }, // Time to process in milliseconds
  retryCount: { type: Number, default: 0 }, // Number of retry attempts
  lastRetryAt: { type: Date, required: false }, // Last retry timestamp
  errorDetails: {
    code: { type: String, required: false }, // Error code
    message: { type: String, required: false }, // Error description
    retryAfter: { type: Date, required: false } // When to retry
  },
  instagramResponse: {
    messageId: { type: String, required: false }, // Instagram's message ID
    status: { type: String, required: false }, // Instagram's delivery status
    timestamp: { type: Date, required: false } // Instagram's timestamp
  }
});

// Message content sub-schema
const MessageContentSchema = new Schema({
  text: { type: String, required: true }, // Message text content
  attachments: [{
    type: { type: String, enum: ['image', 'video', 'audio', 'file'], required: true },
    url: { type: String, required: true },
    caption: { type: String, required: false },
    size: { type: Number, required: false }, // File size in bytes
    mimeType: { type: String, required: false }
  }],
  quickReplies: [{
    text: { type: String, required: true },
    payload: { type: String, required: false }
  }],
  buttons: [{
    type: { type: String, enum: ['web_url', 'postback', 'phone_number'], required: true },
    title: { type: String, required: true },
    url: { type: String, required: false },
    payload: { type: String, required: false },
    phoneNumber: { type: String, required: false }
  }]
});

export interface IMessage extends Document {
  id: string;
  mid: string; // Meta message ID (unique identifier)
  conversationId: string; // Reference to Conversation
  contactId: string; // Reference to Contact (for quick access)
  accountId: string; // Reference to InstagramAccount
  role: 'user' | 'assistant' | 'system'; // Message sender role
  content: {
    text: string;
    attachments: Array<{
      type: string;
      url: string;
      caption?: string;
      size?: number;
      mimeType?: string;
    }>;
    quickReplies: Array<{
      text: string;
      payload?: string;
    }>;
    buttons: Array<{
      type: string;
      title: string;
      url?: string;
      payload?: string;
      phoneNumber?: string;
    }>;
  };
  metadata: {
    timestamp: Date;
    processed: boolean;
    isConsolidated: boolean;
    originalMids: string[];
    aiGenerated: boolean;
    processingTime: number;
    retryCount: number;
    lastRetryAt?: Date;
    errorDetails: {
      code?: string;
      message?: string;
      retryAfter?: Date;
    };
    instagramResponse: {
      messageId?: string;
      status?: string;
      timestamp?: Date;
    };
  };
  status: 'received' | 'queued' | 'processing' | 'sent' | 'failed' | 'delivered' | 'read';
  priority: 'low' | 'normal' | 'high' | 'urgent';
  tags: string[]; // Custom tags for categorization
  notes: string[]; // Internal notes about the message
  isRead: boolean; // Whether the message has been read
  readAt?: Date; // When the message was read
  deliveryConfirmed: boolean; // Whether delivery was confirmed by Instagram
  deliveryConfirmedAt?: Date; // When delivery was confirmed
}

const MessageSchema = new Schema<IMessage>({
  mid: { type: String, required: true, unique: true },
  conversationId: { type: String, required: true },
  contactId: { type: String, required: true },
  accountId: { type: String, required: true },
  role: { type: String, enum: ['user', 'assistant', 'system'], required: true },
  content: { type: MessageContentSchema, required: true },
  metadata: { type: MessageMetadataSchema, default: () => ({}) },
  status: { type: String, enum: ['received', 'queued', 'processing', 'sent', 'failed', 'delivered', 'read'], default: 'received' },
  priority: { type: String, enum: ['low', 'normal', 'high', 'urgent'], default: 'normal' },
  tags: [{ type: String }],
  notes: [{ type: String }],
  isRead: { type: Boolean, default: false },
  readAt: { type: Date, required: false },
  deliveryConfirmed: { type: Boolean, default: false },
  deliveryConfirmedAt: { type: Date, required: false }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Indexes for performance
MessageSchema.index({ conversationId: 1 });
MessageSchema.index({ contactId: 1 });
MessageSchema.index({ accountId: 1 });
MessageSchema.index({ role: 1 });
MessageSchema.index({ status: 1 });
MessageSchema.index({ priority: 1 });
MessageSchema.index({ 'metadata.timestamp': -1 });
MessageSchema.index({ 'metadata.aiGenerated': 1 });
MessageSchema.index({ isRead: 1 });
MessageSchema.index({ deliveryConfirmed: 1 });

// Pre-save middleware to update metadata
MessageSchema.pre('save', function(next) {
  // Update conversation message count
  if (this.isNew) {
    // This will be handled by the conversation service
  }
  
  // Update read status
  if (this.isModified('isRead') && this.isRead && !this.readAt) {
    this.readAt = new Date();
  }
  
  // Update delivery confirmation
  if (this.isModified('deliveryConfirmed') && this.deliveryConfirmed && !this.deliveryConfirmedAt) {
    this.deliveryConfirmedAt = new Date();
  }
  
  next();
});

// Virtual for message age in seconds
MessageSchema.virtual('ageSeconds').get(function() {
  const now = new Date();
  return Math.floor((now.getTime() - this.metadata.timestamp.getTime()) / 1000);
});

// Virtual for message age in minutes
MessageSchema.virtual('ageMinutes').get(function() {
  return Math.floor((Date.now() - this.metadata.timestamp.getTime()) / (1000 * 60));
});

// Virtual for message age in hours
MessageSchema.virtual('ageHours').get(function() {
  return Math.floor((Date.now() - this.metadata.timestamp.getTime()) / (1000 * 60 * 60));
});

// Virtual for message age in days
MessageSchema.virtual('ageDays').get(function() {
  return Math.floor((Date.now() - this.metadata.timestamp.getTime()) / (1000 * 60 * 60 * 24));
});

// Virtual for is recent (within last hour)
MessageSchema.virtual('isRecent').get(function() {
  const ageMinutes = Math.floor((Date.now() - this.metadata.timestamp.getTime()) / (1000 * 60));
  return ageMinutes < 60;
});

// Virtual for is urgent (high priority and recent)
MessageSchema.virtual('isUrgent').get(function() {
  const ageMinutes = Math.floor((Date.now() - this.metadata.timestamp.getTime()) / (1000 * 60));
  return this.priority === 'urgent' && ageMinutes < 30;
});

// Virtual for needs attention (failed or queued for too long)
MessageSchema.virtual('needsAttention').get(function() {
  if (this.status === 'failed') return true;
  const ageMinutes = Math.floor((Date.now() - this.metadata.timestamp.getTime()) / (1000 * 60));
  if (this.status === 'queued' && ageMinutes > 15) return true;
  return false;
});

// Static method to find messages by status
MessageSchema.statics.findByStatus = function(status: string) {
  return this.find({ status });
};

// Static method to find unread messages
MessageSchema.statics.findUnread = function() {
  return this.find({ isRead: false, role: 'user' });
};

// Static method to find failed messages
MessageSchema.statics.findFailed = function() {
  return this.find({ status: 'failed' });
};

// Static method to find messages needing retry
MessageSchema.statics.findNeedingRetry = function() {
  const now = new Date();
  return this.find({
    status: 'failed',
    'metadata.retryCount': { $lt: 3 },
    $or: [
      { 'metadata.errorDetails.retryAfter': { $lte: now } },
      { 'metadata.errorDetails.retryAfter': { $exists: false } }
    ]
  });
};

// Static method to find AI-generated messages
MessageSchema.statics.findAIGenerated = function() {
  return this.find({ 'metadata.aiGenerated': true });
};

// Static method to find messages by conversation
MessageSchema.statics.findByConversation = function(conversationId: string, limit: number = 50) {
  return this.find({ conversationId })
    .sort({ 'metadata.timestamp': -1 })
    .limit(limit);
};

export default mongoose.model<IMessage>('Message', MessageSchema);
