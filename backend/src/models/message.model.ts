import mongoose, { Document, Schema } from 'mongoose';

// Message metadata sub-schema
const MessageMetadataSchema = new Schema({
  timestamp: { type: Date, default: Date.now },
  processed: { type: Boolean, default: false }, // Whether message has been processed by AI
  aiGenerated: { type: Boolean, default: false }, // Generated by AI or rules
  instagramResponse: {
    messageId: { type: String, required: false } // Instagram's message ID
  }
});

// Message content sub-schema
const MessageContentSchema = new Schema({
  text: { type: String, required: true } // Message text content
});

export interface IMessage extends Document {
  id: string;
  mid: string; // Meta message ID (unique identifier)
  conversationId: string; // Reference to Conversation
  contactId: string; // Reference to Contact (for quick access)
  accountId: string; // Reference to InstagramAccount
  recipientId?: string; // Instagram recipient ID (which account received the message)
  role: 'user' | 'assistant' | 'system'; // Message sender role
  content: {
    text: string;
  };
  metadata: {
    timestamp: Date;
    processed: boolean;
    aiGenerated: boolean;
    instagramResponse: {
      messageId?: string;
    };
  };
  status: 'received' | 'queued' | 'processing' | 'sent' | 'failed' | 'delivered' | 'read';
  deliveryConfirmed: boolean; // Whether delivery was confirmed by Instagram
  deliveryConfirmedAt?: Date; // When delivery was confirmed
}

const MessageSchema = new Schema<IMessage>({
  mid: { type: String, required: true, unique: true },
  conversationId: { type: String, required: true },
  contactId: { type: String, required: true },
  accountId: { type: String, required: true },
  recipientId: { type: String, required: false }, // Instagram recipient ID
  role: { type: String, enum: ['user', 'assistant', 'system'], required: true },
  content: { type: MessageContentSchema, required: true },
  metadata: { type: MessageMetadataSchema, default: () => ({}) },
  status: { type: String, enum: ['received', 'queued', 'processing', 'sent', 'failed', 'delivered', 'read'], default: 'received' },
  deliveryConfirmed: { type: Boolean, default: false },
  deliveryConfirmedAt: { type: Date, required: false }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Indexes for performance
MessageSchema.index({ conversationId: 1 });
MessageSchema.index({ contactId: 1 });
MessageSchema.index({ accountId: 1 });
MessageSchema.index({ recipientId: 1 });
MessageSchema.index({ role: 1 });
MessageSchema.index({ status: 1 });
MessageSchema.index({ 'metadata.timestamp': -1 });
MessageSchema.index({ 'metadata.aiGenerated': 1 });
MessageSchema.index({ deliveryConfirmed: 1 });

// Pre-save middleware to update metadata
MessageSchema.pre('save', function(next) {
  // Update delivery confirmation
  if (this.isModified('deliveryConfirmed') && this.deliveryConfirmed && !this.deliveryConfirmedAt) {
    this.deliveryConfirmedAt = new Date();
  }
  
  next();
});

// Virtual for message age in seconds
MessageSchema.virtual('ageSeconds').get(function() {
  const now = new Date();
  return Math.floor((now.getTime() - this.metadata.timestamp.getTime()) / 1000);
});

// Static method to find messages by status
MessageSchema.statics.findByStatus = function(status: string) {
  return this.find({ status });
};

// Static method to find failed messages
MessageSchema.statics.findFailed = function() {
  return this.find({ status: 'failed' });
};

// Static method to find AI-generated messages
MessageSchema.statics.findAIGenerated = function() {
  return this.find({ 'metadata.aiGenerated': true });
};

// Static method to find messages by conversation
MessageSchema.statics.findByConversation = function(conversationId: string, limit: number = 50) {
  return this.find({ conversationId })
    .sort({ 'metadata.timestamp': -1 })
    .limit(limit);
};

export default mongoose.model<IMessage>('Message', MessageSchema);
